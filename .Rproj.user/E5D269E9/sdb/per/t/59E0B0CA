{
    "contents" : "#' createSubInputData\n#'\n#'\n#' @param ioSubEnv a global environment variable\n\ncreateSubOutputGraphs <- function( ioSubEnv ){\n\n  # Set the directory that will contain all the reconstructed subgraphs\n  tmp.dirPath <- file.path(ioSubEnv$output.dirPath, \"subGraphs\")\n  if(!dir.exists(tmp.dirPath)){dir.create(tmp.dirPath)}\n  if(!dir.exists(file.path(tmp.dirPath, \"subOutput\"))){dir.create(file.path(tmp.dirPath, \"subOutput\"))}\n\n  # --!-- Time\n  time.multiReconstruction.output.start <- proc.time()\n\n  if(ioSubEnv$subset.select %in% c(\"spectral\", \"random\")){\n\n    # Create all command lines\n    # --> define the input sub data set file template\n    subInData.filePath.template = file.path(tmp.dirPath, \"subInput\", paste(\"eigenVector\", \"XXX_IEIGEN_XXX\", \"_\", ioSubEnv$subset.m,\"XXX_SIGN_XXX.tsv\", sep=''))\n    subOutData.filePath.template = gsub( \"subInput\", \"subOutput\", gsub(\".tsv\", \"\", subInData.filePath.template))\n\n    # Build a call template\n    cmd.template <- \"\"\n    if(ioSubEnv$recons.method == \"bayes_hc\"){\n      cmd.template <- paste( \"rMethod.hc(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argScore = '\", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"score\"]], \"', argRestart = \", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"restart\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \")\", sep = \"\")\n\n    } else if(ioSubEnv$recons.method == \"aracne\"){\n      cmd.template <- paste( \"rMethod.aracne(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argEstimator = '\", ioSubEnv$recons.param[[\"aracne\"]][[\"estimator\"]], \"', argEpsilon = \", ioSubEnv$recons.param[[\"aracne\"]][[\"epsilon\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \")\", sep = \"\")\n    }\n\n    # --> set with the eigen value number and sign\n    cmd.template.split <- unlist(strsplit(cmd.template, split = \"XXX_IEIGEN_XXX\"))\n    cmd.iEigen.paste <- paste(cmd.template.split[1], seq_len(ncol(ioSubEnv$eigen.vectors))[-1],\n                              cmd.template.split[2], seq_len(ncol(ioSubEnv$eigen.vectors))[-1],\n                              cmd.template.split[3], sep='')\n\n    cmd.all <- c(gsub(\"XXX_SIGN_XXX\", \"pos\", cmd.iEigen.paste), gsub(\"XXX_SIGN_XXX\", \"neg\", cmd.iEigen.paste))\n    # print(cmd.all[1]); stop()\n\n    # Call the command in parallel\n    doParallel::registerDoParallel(cores = ioSubEnv$nbCPU)\n    tmpOut <- foreach(i=1:length(cmd.all)) %dopar%{ eval(parse(text = cmd.all[i])) }\n\n  } else if(ioSubEnv$subset.select %in% c(\"spectralKmeans\", \"spectralFuzzyCmeansOrder\",\n                                          \"spectralFuzzyCmeansSample\", \"spectralBipartition\")){\n\n    # Create all command lines\n    # --> define the input sub data set file template\n    subInData.filePath.template <- file.path(tmp.dirPath, \"subInput\", paste(ioSubEnv$subset.select, \"XXX_ICLUST_XXX\", \"_\", ioSubEnv$subset.m,\".tsv\", sep=''))\n    subOutData.filePath.template <- gsub( \"subInput\", \"subOutput\", gsub(\".tsv\", \"\", subInData.filePath.template))\n\n    # Build a call template\n    cmd.template <- \"\"\n    if(ioSubEnv$recons.method == \"bayes_hc\"){\n      cmd.template <- paste( \"rMethod.hc(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argScore = '\", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"score\"]], \"', argRestart = \", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"restart\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \")\", sep = \"\")\n\n    } else if(ioSubEnv$recons.method == \"aracne\"){\n      cmd.template <- paste( \"rMethod.aracne(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argEstimator = '\", ioSubEnv$recons.param[[\"aracne\"]][[\"estimator\"]], \"', argEpsilon = \", ioSubEnv$recons.param[[\"aracne\"]][[\"epsilon\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \")\", sep = \"\")\n    }\n\n#     cmd.template <- paste( \"cd \", file.path(ioSubEnv$reconsMeth.dirPath, ioSubEnv$recons.method), \";\", \" ./\", ioSubEnv$recons.script, \" -i \",\n#                            subInData.filePath.template, \" -o \", subOutData.filePath.template, \" \", ioSubEnv$recons.param, sep = \"\")\n    # --> set with the cluster number\n    cmd.template.split <- unlist(strsplit(cmd.template, split = \"XXX_ICLUST_XXX\"))\n\n    cmd.iClust.paste <- \"\"\n    if(ioSubEnv$subset.select == \"spectralKmeans\"){\n\n      cmd.iClust.paste <- paste(cmd.template.split[1], seq_len(ioSubEnv$kmeans.k),\n                                cmd.template.split[2], seq_len(ioSubEnv$kmeans.k),\n                                cmd.template.split[3], sep='')\n\n    } else if(ioSubEnv$subset.select == \"spectralFuzzyCmeansOrder\"){\n\n      cmd.iClust.paste <- paste(cmd.template.split[1], seq_len(ioSubEnv$cmeans.k),\n                                cmd.template.split[2], seq_len(ioSubEnv$cmeans.k),\n                                cmd.template.split[3], sep='')\n\n    } else if(ioSubEnv$subset.select == \"spectralBipartition\"){\n\n      cmd.iClust.paste <- paste(cmd.template.split[1], unique(ioSubEnv$specBi.allClusters),\n                                cmd.template.split[2], unique(ioSubEnv$specBi.allClusters),\n                                cmd.template.split[3], sep='')\n\n    } else if(ioSubEnv$subset.select == \"spectralFuzzyCmeansSample\"){\n\n      # Create all command lines\n      # --> define the input sub data set file template\n      subInData.filePath.template <- file.path(tmp.dirPath, \"subInput\",\n                                               paste(ioSubEnv$subset.select, \"XXX_ICLUST_XXX\", \"_\", ioSubEnv$subset.m,\"_XXX_IVARSPL_XXX.tsv\", sep=''))\n      subOutData.filePath.template <- gsub( \"subInput\", \"subOutput\", gsub(\".tsv\", \"\", subInData.filePath.template))\n\n      # Build a call template\n      cmd.template <- \"\"\n      if(ioSubEnv$recons.method == \"bayes_hc\"){\n        cmd.template <- paste( \"try(rMethod.hc(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argScore = '\", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"score\"]], \"', argRestart = \", ioSubEnv$recons.param[[\"bayes_hc\"]][[\"restart\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \"))\", sep = \"\")\n\n      } else if(ioSubEnv$recons.method == \"aracne\"){\n        cmd.template <- paste( \"try(rMethod.aracne(argInData = '\", subInData.filePath.template, \"', argOutDir = '\", subOutData.filePath.template, \"', argEstimator = '\", ioSubEnv$recons.param[[\"aracne\"]][[\"estimator\"]], \"', argEpsilon = \", ioSubEnv$recons.param[[\"aracne\"]][[\"epsilon\"]], \", argVerbose = \", as.character(ioSubEnv$verbose), \"))\", sep = \"\")\n      }\n#       cmd.template <- paste( \"cd \", file.path(ioSubEnv$reconsMeth.dirPath, ioSubEnv$recons.method), \";\", \" ./\", ioSubEnv$recons.script, \" -i \",\n#                              subInData.filePath.template, \" -o \", subOutData.filePath.template, \" \", ioSubEnv$recons.param, sep = \"\")\n\n      cmd.iClust.paste <- c()\n      # iNbVarSpl = 1\n      for(iNbVarSpl in seq_len(ioSubEnv$cmeans.nbVarSample)){\n\n        # Set the number of the assignment\n        tmp.cmd.template <- gsub(\"XXX_IVARSPL_XXX\", iNbVarSpl, cmd.template)\n\n        # --> set with the cluster number\n        tmp.cmd.template.split <- unlist(strsplit(tmp.cmd.template, split = \"XXX_ICLUST_XXX\"))\n\n        cmd.iClust.paste <- c( cmd.iClust.paste,\n                               paste(tmp.cmd.template.split[1], seq_len(ioSubEnv$cmeans.k),\n                                     tmp.cmd.template.split[2], seq_len(ioSubEnv$cmeans.k),\n                                     tmp.cmd.template.split[3], sep=''))\n      }\n    }\n\n    cmd.all <- cmd.iClust.paste\n    # print(cmd.all[1]); stop()\n\n    # Call the command in parallel\n    # i = 1\n    doParallel::registerDoParallel(cores = ioSubEnv$nbCPU)\n    tmpOut <- foreach(i=1:length(cmd.all)) %dopar%{\n      print(cmd.all[i])\n      eval(parse(text = cmd.all[i]))\n    }\n\n#     for(i in c(1:length(cmd.all))){\n#       print(cmd.all[i])\n#       eval(parse(text = cmd.all[i]))\n#     }\n\n  } else { stop(\"# Not implemented yet...\") }\n\n  # --!-- Time\n  ioSubEnv$outputs.time <- (proc.time() - time.multiReconstruction.output.start)\n  ioSubEnv$total.time <- ioSubEnv$total.time + ioSubEnv$outputs.time\n}\n",
    "created" : 1470647930191.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2972389476",
    "id" : "59E0B0CA",
    "lastKnownWriteTime" : 1469389804,
    "path" : "~/Projects/Projects_largeScale/package/ScaleNet_V1.2/R/createSubOutputGraphs.R",
    "project_path" : "R/createSubOutputGraphs.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}
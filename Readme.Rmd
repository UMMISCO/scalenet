---
title: "Readme"
author: "Edi Prifti"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(scalenet)
library(igraph)
```

## Installation guide

```{r}
# install the CRAN packages
install.packages(c("doSNOW", "doParallel", "bnlearn","fpc","e1071","prettyR", "graph", "igraph"), dependencies = TRUE)

# There is a bioconductor package

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(c("graph", "Rgraphviz", "minet"))
```

## Load the data


```{r warning=FALSE, include=FALSE}
pop2mat <- read.delim("tests/data/pop2mat.txt")
colnames(pop2mat) <- gsub("\\.","-",colnames(pop2mat))

tmp <- scs(workspaceDir = "scalent_results",
           #argInData = "/Users/eprifti/Research/akkersisters/pooled_cohort_baseline_MGS.txt",
           # argInData = "tests/data/pop2mat.txt",
           argInData = pop2mat,
           argReconsMeth = c("aracne", "bayes_hc"),
           argReconsMethInfo = list(aracne = list(ort = "n", eweight = "epresenceScore"), bayes_hc = list(ort = "y", eweight = "ecorr")),
           argEmbReconsParam = list(aracne = list(estimator="mi.mm", epsilon=0.001), bayes_hc = list(score="bde", restart=21), varPerc = 0.2),
           argPresFreqThresh = c(0.3, 0.8), clean.workspace = FALSE, argDiscretize = TRUE, argVerbose = TRUE)

```

Load annotations

```{r}
# node annotation
load("tests/data/mgs_taxo.rda"); taxo <- mgs_taxo; rm(mgs_taxo)
rownames(taxo) <- gsub(":","-",rownames(taxo))
size <- as.numeric(as.character(taxo$size)); plot(size)


# fname <- "scalent_results/consensusGraph/pop2mat_consensusNetpresFreq1/edgesList.txt"
fname <- "scalent_results/consensusGraph/globalNet_presFreq0.8/edgesList.txt"
# upper.perc <- 3
# upper.fix <- 307

# load the edge information for spectral3off2 network
edges <- read.delim(fname, as.is = TRUE); dim(edges) # 1183 edges and 7 columns
edges.raw <- edges # save it
# remove edges that do not have an orientation
edges <- edges[!is.na(edges$eorientScore),]; dim(edges) # 193 edges
colnames(edges)[1:2] <- c("from","to")
# edges$from <- gsub("\\.",":",edges$x)
# edges$to <- gsub("\.",":",edges$y)
rownames(edges) <- paste(edges$from, edges$to, sep=" => ")

```

Make the graph
```{r}
# BUILD NETWORK
#-------------------------------------------------------------------------------------------
# ANNOTATION of the edges
edges.annot <- taxo[unique(c(edges$from,edges$to)),]; edges.annot <- data.frame(rownames(edges.annot),edges.annot);
colnames(edges.annot)[match("name",colnames(edges.annot))] <- "name_long"; colnames(edges.annot)[1] <- "name"

# Build the igraph netowrk
require(igraph)
# create the igraph object
gD <- graph.data.frame(d = edges, directed = TRUE, vertices = edges.annot)

# Calculate degree for all nodes
degAll <- igraph::degree(gD, v = V(gD), mode = "all")
gD <- set.vertex.attribute(gD, "degree", index = V(gD)$name, value = degAll)
# Calculate betweenness for all nodes
betAll <- igraph::betweenness(gD, v = V(gD), directed = FALSE) / (((vcount(gD) - 1) * (vcount(gD)-2)) / 2)
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll)); rm(betAll)
# Add new node/edge attributes based on the calculated node properties/similarities
gD <- set.vertex.attribute(gD, "betweenness", index = V(gD)$name, value = betAll.norm)

# Calculate edge properties and add to the network
E(gD)$infOrt[E(gD)$infOrt==1] <- 0; E(gD)$infOrt[E(gD)$infOrt==-2] <- 1
#Calculate Dice similarities between all pairs of nodes
dsAll <- similarity.dice(gD, vids = V(gD), mode = "all")
# The following function will transform a square matrix to an edge driven one and add values to each edge
F1 <- function(x) {data.frame(dice = dsAll[which(V(gD)$name == as.character(x$from)), which(V(gD)$name == as.character(x$to))])}
library(plyr)
edges.ext <- ddply(edges, .variables=c("from", "to"), function(x) data.frame(F1(x))); dim(edges.ext)

gD <- set.edge.attribute(gD, "similarity", index = E(gD), value = 0)
E(gD)[as.character(edges.ext$from) %--% as.character(edges.ext$to)]$similarity <- as.numeric(edges.ext$dice)
# Edge color
E(gD)$color <- c("#DC143C","#A6A6A6")[as.factor(factor(sign(E(gD)$eorient), levels=c('-1','1')))]

# fix orientation coding
# 1 backward
# 2 forward
# 3 bidirected (on laisse 0)
E(gD)$eorient[E(gD)$eorient==1] <- 2
E(gD)$eorient[E(gD)$eorient==-1] <- 1


# #check things out
# node <- "akker"
# dataSet[dataSet$node1 == node,]; dataSet[dataSet$node2 == node,]
# node <- "GU:107"
# dataSet.ext[dataSet.ext$node1 == node,]; dataSet.ext[dataSet.ext$node2 == node,]

# Check the attributes
# Print number of nodes and edges
print(paste("There are",vcount(gD),"nodes and",ecount(gD),"edges"))
# [1] "There are 765 nodes and 1597 edges"
summary(gD)
# IGRAPH DN-- 443 307 --
#   + attr: name (v/c), size (v/n), NA_pc (v/n), BHit_pc (v/n), BHit (v/c), BH_ali (v/n), BH_id (v/n),
# | NA_pc_ (v/n), Taxo_pc (v/n), Taxo (v/c), Taxo_ali (v/n), Taxo_id (v/n), Taxo_level (v/c), annot
# | (v/c), species (v/c), genus (v/c), family (v/c), order (v/c), class (v/c), phylum (v/c),
# | superkingdom (v/c), name_long (v/c), color (v/c), degree (v/n), betweenness (v/n), type (e/c), ui
# | (e/l), info (e/n), cplx (e/n), Nxy_ui (e/l), confidence (e/n), infOrt (e/n), trueOrt (e/l), isOrt
# | (e/l), isOrtOk (e/l), essential (e/l), sign (e/c), diff (e/n), similarity (e/n), color (e/c)

l <- layout.fruchterman.reingold(gD)
# l <- layout.auto(gD)
# l <- layout.random(gD)
# l <- layout.circle(gD)
# l <- layout.sphere(gD)
# l <- layout.kamada.kawai(gD)
# l <- layout.reingold.tilford(gD)
# l <- layout.lgl(gD)
# l <- layout.graphopt(gD)

pdf(file=paste("igraph.pdf",sep=""),width = 10,height = 10)
plot(gD,
     vertex.label = V(gD)$name_long,
     vertex.size=log10(V(gD)$size)*3,
     edge.arrow.size=.4,
     asp=TRUE,
     rescale=TRUE,
     layout=l,
     edge.arrow.mode = E(gD)$eorient,
     vertex.label.cex = 0.7,
     vertex.label.dist=0)
#plot(gD, vertex.label = NA, vertex.size=log10(V(gD)$size), edge.arrow.size=.4, asp=TRUE, rescale=TRUE, layout=l)
dev.off()
save(gD, edges, edges.raw, l, file=paste("graph_data.rda",sep=""))
```


{
    "contents" : "#' LaplacianRW\n#'\n#' LaplacianRW computes the LAPLACIAN MATRIX, Lrw=D^-1.L=I-D^-1.W, where W is the\n#' mutual information matrix, D=diag(di) and di=sum(Coli)\n#'\n#' @param ioSubEnv a global environment variable\n\nLaplacianRW <- function(ioSubEnv){\n\n  tmp.inputFileName <- basename(ioSubEnv$inputData.filePath)\n  tmp.path <- gsub(tmp.inputFileName,'', ioSubEnv$inputData.filePath)\n  tmp.path <- file.path(tmp.path, \"ScaleNet\")\n  if(!dir.exists(tmp.path)){dir.create(tmp.path)}\n\n  # MAKE AFFINITY\n  tmp.path.affinity.mat <- file.path(tmp.path, gsub(\".txt$\", \"_affinity.mat.rds\", tmp.inputFileName))\n  tmp.path.affinity.mat.time <- file.path(tmp.path, gsub(\".txt$\", \"_affinity.time.rds\", tmp.inputFileName))\n\n  if(!file.exists(tmp.path.affinity.mat)){\n\n    # Compute the mutual information matrix if it does no exists yet\n    cat(\"# --> ... the mutual information matrix (\", ioSubEnv$mi.estimator, \"estimator)\\n# ---\\n\")\n\n    # --!-- Time\n    time.affinity.start <- proc.time()\n\n    # Initialize the affinity matrix\n    ioSubEnv$affinity.mat <- matrix(0, ncol = ncol(ioSubEnv$allData), nrow = ncol(ioSubEnv$allData))\n    colnames(ioSubEnv$affinity.mat) = rownames(ioSubEnv$affinity.mat) = colnames(ioSubEnv$allData)\n\n    # --> compute the mutual information matrix\n    ioSubEnv$affinity.mat <- minet::build.mim(as.data.frame(ioSubEnv$allData),\n                                              estimator = ioSubEnv$mi.estimator)\n\n    # --> If some values are missing (NA/Nan), set to 0 the affinity\n    tmp.naArrIdx <- which(is.na(ioSubEnv$affinity.mat), arr.ind = TRUE)\n    if(nrow(tmp.naArrIdx) > 0){\n      ioSubEnv$affinity.mat[tmp.naArrIdx] <- 0\n    }\n\n    # --!-- Time\n    ioSubEnv$affinity.mat.time <- (proc.time() - time.affinity.start)\n\n    # Save the affinity matrix and computation time for futur use\n    saveRDS(ioSubEnv$affinity.mat, tmp.path.affinity.mat)\n    saveRDS(ioSubEnv$affinity.mat.time, tmp.path.affinity.mat.time)\n\n  } else{\n\n    # Load the computed affinity matrix and computation time\n    ioSubEnv$affinity.mat <- readRDS(tmp.path.affinity.mat)\n    ioSubEnv$affinity.mat.time <- readRDS(tmp.path.affinity.mat.time)\n  }\n  # Add to total time (in fact set here...)\n  ioSubEnv$total.time <- ioSubEnv$affinity.mat.time\n\n  if(ioSubEnv$verbose){\n    cat(\"\\n# --| Head of MIM data:\\n\")\n    cat(\"# -----------------------------\\n\")\n    print(ioSubEnv$affinity.mat[1:5,1:5])\n    print(dim(ioSubEnv$affinity.mat))\n    print(ioSubEnv$affinity.mat.time)\n    cat(\"# -----------------------------\\n\")\n  }\n\n  # MAKE DECOMPOSE\n  tmp.path.decompose.mat <- file.path(tmp.path, gsub(\".txt$\", \"_decomp.mat.rds\", tmp.inputFileName))\n  tmp.path.decompose.mat.time <- file.path(tmp.path, gsub(\".txt$\", \"_decomp.time.rds\", tmp.inputFileName))\n\n  if(!file.exists(tmp.path.decompose.mat)){\n\n    # --> init the matrice to be decomposed with the similarity matrix\n    ioSubEnv$decompose.mat <- ioSubEnv$affinity.mat\n\n    if(ioSubEnv$similarityType == \"Lrw\"){\n\n      # --!-- Time\n      time.laplacian.start <- proc.time()\n\n      # Compute the 'normalized Laplacian matrix'\n      tmp.degree = diag(apply(ioSubEnv$affinity.mat, 2, sum, na.rm = TRUE))\n      colnames(tmp.degree) = rownames(tmp.degree) = colnames(ioSubEnv$allData)\n\n      # Remove the variables not associated to any others (di == 0)\n      tmp.diagNull.idx <- which(apply(tmp.degree, 1, sum) == 0)\n\n      if(length(tmp.diagNull.idx) == ncol(tmp.degree)){\n\n        cat(\"# --> All variables have zero degree\\n\")\n        quit(save = \"no\", status = 0)\n\n      } else if(length(tmp.diagNull.idx)>0){\n\n        cat(\"# --> The variables [\", paste(colnames(ioSubEnv$affinity.mat)[tmp.diagNull.idx],\n                                           collapse = ', '), \"] have zero degree --> ignored!\\n\")\n\n        # Resize the degree and affinity matrix\n        ioSubEnv$affinity.mat <- ioSubEnv$affinity.mat[-tmp.diagNull.idx,-tmp.diagNull.idx]\n        tmp.degree <- tmp.degree[-tmp.diagNull.idx,-tmp.diagNull.idx]\n\n        if(ncol(tmp.degree) < ioSubEnv$subset.m){\n\n          cat(\"# --> The number of nodes per subgraph is greater that the number of connected variables\\n\")\n          quit(save = \"no\", status = 0)\n        }\n\n      } else { cat(\"# --> [.LaplacianRW] All variables have a none zero degree\\n\") }\n\n      if(ioSubEnv$verbose){\n        cat(\"\\n# --| Head of MIM degree:\\n\")\n        cat(\"# -----------------------------\\n\")\n        print(tmp.degree[1:5,1:5])\n        print(dim(tmp.degree))\n        cat(\"# -----------------------------\\n\")\n      }\n\n      # Invert the degree matrix\n      tmp.degree.inv <- solve(tmp.degree)\n\n      # Compute the Lwr matrix\n      ioSubEnv$decompose.mat = (diag(nrow(ioSubEnv$affinity.mat)) - tmp.degree.inv %*% ioSubEnv$affinity.mat)\n\n      # --!-- Time\n      ioSubEnv$decompose.mat.time <- (proc.time() - time.laplacian.start)\n\n      # Save the decompose matrix and computation time for futur use\n      saveRDS(ioSubEnv$decompose.mat, tmp.path.decompose.mat)\n      saveRDS(ioSubEnv$decompose.mat.time, tmp.path.decompose.mat.time)\n\n    }else{cat(stop(\"# Not implemented yet...\"))}\n\n  } else {\n\n    # Load the computed decompose matrix and computation time\n    ioSubEnv$decompose.mat <- readRDS(tmp.path.decompose.mat)\n    ioSubEnv$decompose.mat.time <- readRDS(tmp.path.decompose.mat.time)\n  }\n  # Add to total time\n  ioSubEnv$total.time <- ioSubEnv$total.time + ioSubEnv$decompose.mat.time\n\n  if(ioSubEnv$verbose){\n    cat(\"\\n# --| Head of Lwr:\\n\")\n    cat(\"# -----------------------------\\n\")\n    print(ioSubEnv$decompose.mat[1:5,1:5])\n    print(dim(ioSubEnv$decompose.mat))\n    print(ioSubEnv$decompose.mat.time)\n    cat(\"# -----------------------------\\n\")\n  }\n}\n",
    "created" : 1470646471282.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2134971416",
    "id" : "B0581BF",
    "lastKnownWriteTime" : 1467994170,
    "path" : "~/Projects/Projects_largeScale/package/ScaleNet_V1.2/R/LaplacianRW.R",
    "project_path" : "R/LaplacianRW.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}
{
    "contents" : "#' scaleNet.gatherSubGraphs\n#'\n#' Gather the sub graphs\n#' - if the input datasets are based on spectralFuzzyCmeansSample\n#' - save a globalNet for each assignment (up to ioSubEnv$nbVarSample)\n#'\n#'\n#' @param ioSubEnv a global environment variable\n\nscaleNet.gatherSubGraphs <- function(ioSubEnv, iVarSpl){\n\n  # --!-- Time\n  time.globalReconstruction.start <- proc.time()\n\n  # Set all possible pairs for the global network\n  allPairs <- combn(colnames(ioSubEnv$allData), 2)\n\n  # Define an output table for the gathered information\n  # --> here, the counts are made on the pair presence, orientation, or possible (ie. pair in the dataset)\n  cat(\"# Set globalNet....\\n\")\n  globalNet.colnames <- c(\"presence\", \"forward\", \"backward\", \"possible\")\n  globalNet <- matrix(0, ncol = length(globalNet.colnames), nrow = ncol(allPairs))\n  colnames(globalNet) <- globalNet.colnames\n  rownames(globalNet) <- paste(allPairs[1,], allPairs[2,], sep = \"_<<_\")\n\n  if(ioSubEnv$verbose){\n    cat(\"# --|\", paste(head(colnames(globalNet)), collapse = ','), \"...\\n\")\n    cat(\"# --| nbPairs:\", dim(globalNet)[1],\"\\n\")\n  }\n\n  # Keep complementary info\n  # --> For all reconstruction method, keep the eigenvector or cluster number that gives the presence\n  globalNet.cmpl.colnames <- c(\"eigen\", \"cluster\", \"epresenceScore\")\n\n  # --> Create a data frame for complementary information with the rownames corresponding to globalNet\n  globalNet.cmpl <- as.data.frame(matrix(ncol = length(globalNet.cmpl.colnames), nrow = nrow(globalNet)))\n  rownames(globalNet.cmpl) <- rownames(globalNet)\n  colnames(globalNet.cmpl) <- globalNet.cmpl.colnames\n\n  # Set the directory path where all subnetworks can be found\n  tmp.dirPath <- file.path(ioSubEnv$output.dirPath, \"subGraphs\")\n  if(dir.exists(tmp.dirPath) == FALSE){stop(\"# Not local network found!\")}\n\n  if(ioSubEnv$subset.select %in% c(\"spectral\", \"random\")){\n\n    # iEigen <- 2\n    for(iEigen in c(2:ncol(ioSubEnv$eigen.vectors))){\n\n      # strSign <- \"pos\"\n      for(strSign in c(\"pos\", \"neg\")){\n\n        # Define the network summary file path\n        summary.fileName <- paste(\"edgesList\", ioSubEnv$recons.method, \"txt\", sep = '.')\n\n        subOutData.summaryPath.template = file.path(tmp.dirPath, \"subOutput\",\n                                                    paste(\"eigenVector\", \"XXX_IEIGEN_XXX\", \"_\",\n                                                          ioSubEnv$subset.m, strSign, sep=''),\n                                                    summary.fileName)\n        # Load the sub graph summary\n        tmp.subNet.filePath <- gsub( \"XXX_IEIGEN_XXX\", as.character(iEigen), subOutData.summaryPath.template)\n        if(!file.exists(tmp.subNet.filePath)){next}\n        tmp.subNet <- read.table(file = tmp.subNet.filePath, header = TRUE, row.names = 1, sep = '\\t', as.is = TRUE)\n\n        # Create a new format for the sub graph summary that fits the globalNet data file format\n        # --> make the addition easier!!\n        # --> this is why the colnames order of sub datasets is important!!\n        tmp.subNet.newFormat <- matrix(0, ncol = ncol(globalNet), nrow = nrow(tmp.subNet) )\n        # --> same columns as globalNet\n        colnames(tmp.subNet.newFormat) <- colnames(globalNet)\n        # --> same row as subNet\n        rownames(tmp.subNet.newFormat) <- paste(tmp.subNet[,\"x\"], tmp.subNet[,\"y\"], sep = \"_<<_\")\n\n        # Set all pairs of the subgraph as 'possible' (ie. visited)\n        tmp.subNet.newFormat[,\"possible\"] <- rep(1,nrow(tmp.subNet.newFormat))\n\n        # Set the presence of edges, and their possible orientation\n        if(length(which(tmp.subNet[,\"epresence\"] == 1)) > 0){\n\n          # If an edge has been inferred, set the 'presence' to 1\n          tmp.subNet.newFormat[(tmp.subNet[,\"epresence\"] == 1),\"presence\"] <- 1\n\n          # Set also the orientation\n          # --> as the variable names order is respected, the fwd/bck sign is also the same\n          if(length(which(tmp.subNet[,\"eorient\"] == 2)) > 0){\n            tmp.subNet.newFormat[(tmp.subNet[,\"eorient\"] == 2),\"forward\"] <- 1\n          }\n\n          if(length(which(tmp.subNet[,\"eorient\"] == -2)) > 0){\n            tmp.subNet.newFormat[(tmp.subNet[,\"eorient\"] == -2),\"backward\"] <- 1\n          }\n        }\n\n        # Find the rownames of the new format subgraph in globalNet data file\n        tmp.match <- match(rownames(tmp.subNet.newFormat), rownames(globalNet))\n\n        # Add the counts from the subgraph to global net\n        globalNet[tmp.match,] <-(globalNet[tmp.match,] + tmp.subNet.newFormat[c(1:length(tmp.match)),])\n\n        # Keep also the eigen vector number and the edge score into a separated data frame when an edge has been inferred\n        tmp.presence.key <- rownames(tmp.subNet.newFormat)[(tmp.subNet[,\"epresence\"] == 1)]\n        if(length(tmp.presence.key) > 0){\n          globalNet.cmpl[tmp.presence.key, \"eigen\"] <- paste(globalNet.cmpl[tmp.presence.key, \"eigen\"],\n                                                             rep(iEigen, length(tmp.presence.key)), sep = ',')\n\n          globalNet.cmpl[tmp.presence.key, \"epresenceScore\"] <- paste(globalNet.cmpl[tmp.presence.key, \"epresenceScore\"],\n                                                              tmp.subNet[tmp.presence.key, \"epresenceScore\"], sep = ',')\n        }\n      }\n    }\n\n  } else if(ioSubEnv$subset.select %in% c(\"spectralKmeans\", \"spectralFuzzyCmeansOrder\",\n                                          \"spectralBipartition\", \"spectralFuzzyCmeansSample\")){\n    # Set the cluster numbers\n    nbClusters <- c()\n    if(ioSubEnv$subset.select == \"spectralKmeans\"){\n      nbClusters <- seq_len(ioSubEnv$kmeans.k)\n\n    } else if(ioSubEnv$subset.select %in% c(\"spectralFuzzyCmeansOrder\", \"spectralFuzzyCmeansSample\")){\n      nbClusters <- seq_len(ioSubEnv$cmeans.k)\n\n    } else if(ioSubEnv$subset.select == \"spectralBipartition\"){\n      nbClusters <- unique(ioSubEnv$specBi.allClusters)\n    }\n\n    # iClust = nbClusters[1]\n    for(iClust in nbClusters){\n\n      # Define the network summary file path\n      summary.fileName <- paste(\"edgesList\", ioSubEnv$recons.method, \"txt\", sep = '.')\n\n      subOutData.summaryPath.template <- \"\"\n      if(ioSubEnv$subset.select == \"spectralFuzzyCmeansSample\"){\n\n        subOutData.summaryPath.template <- file.path(tmp.dirPath, \"subOutput\",\n                                                     paste(ioSubEnv$subset.select, \"XXX_ICLUST_XXX\", \"_\",\n                                                           ioSubEnv$subset.m, \"_\", iVarSpl, sep=''),\n                                                     summary.fileName)\n\n      } else {\n\n        subOutData.summaryPath.template <- file.path(tmp.dirPath, \"subOutput\",\n                                                     paste(ioSubEnv$subset.select, \"XXX_ICLUST_XXX\", \"_\",\n                                                           ioSubEnv$subset.m, sep=''),\n                                                     summary.fileName)\n      }\n\n      # Load the sub graph summary\n      tmp.subNet.filePath <- gsub( \"XXX_ICLUST_XXX\", as.character(iClust), subOutData.summaryPath.template)\n      if(!file.exists(tmp.subNet.filePath)){next}\n      tmp.subNet <- read.table(file = tmp.subNet.filePath, header = TRUE, row.names = 1, sep = '\\t', as.is = TRUE)\n\n      # Create a new format for the sub graph summary that fits the globalNet data file format\n      # --> make the addition easier!!\n      # --> this is why the colnames order of sub datasets are important!!\n      tmp.subNet.newFormat <- matrix(0, ncol = ncol(globalNet), nrow = nrow(tmp.subNet) )\n      # --> same columns as globalNet\n      colnames(tmp.subNet.newFormat) <- colnames(globalNet)\n      # --> same row as subNet\n      rownames(tmp.subNet.newFormat) <- paste(tmp.subNet[,\"x\"], tmp.subNet[,\"y\"], sep = \"_<<_\")\n\n      # Set all pairs of the subgraph as 'possible' (ie. visited)\n      tmp.subNet.newFormat[,\"possible\"] <- rep(1,nrow(tmp.subNet.newFormat))\n\n      # Set the presence of edges, and their possible orientation\n      if(length(which(tmp.subNet[,\"epresence\"] == 1)) > 0){\n\n        # If an edge has been inferred, set the 'presence' to 1\n        tmp.subNet.newFormat[(tmp.subNet[,\"epresence\"] == 1),\"presence\"] <- 1\n\n        # Set also the orientation\n        # --> as the variable names order is respected, the fwd/bck sign is also the same\n        if(length(which(tmp.subNet[,\"eorient\"] == 2)) > 0){\n          tmp.subNet.newFormat[(tmp.subNet[,\"eorient\"] == 2),\"forward\"] <- 1\n        }\n\n        if(length(which(tmp.subNet[,\"eorient\"] == -2)) > 0){\n          tmp.subNet.newFormat[(tmp.subNet[,\"eorient\"] == -2),\"backward\"] <- 1\n        }\n      }\n\n      # Find the rownames of the new format subgraph in globalNet data file\n      tmp.match <- match(rownames(tmp.subNet.newFormat), rownames(globalNet))\n\n      # Add the counts from the subgraph to global net\n      globalNet[tmp.match,] <-(globalNet[tmp.match,] + tmp.subNet.newFormat[c(1:length(tmp.match)),])\n\n      # Keep also the cluster number into a separated data frame when an edge has been inferred\n      tmp.presence.key <- rownames(tmp.subNet.newFormat)[(tmp.subNet[,\"epresence\"] == 1)]\n      if(length(tmp.presence.key) > 0){\n        globalNet.cmpl[tmp.presence.key, \"cluster\"] <- paste(globalNet.cmpl[tmp.presence.key, \"cluster\"],\n                                                             rep(iClust, length(tmp.presence.key)), sep = ',')\n\n        globalNet.cmpl[tmp.presence.key, \"epresenceScore\"] <- paste(globalNet.cmpl[tmp.presence.key, \"epresenceScore\"],\n                                                            tmp.subNet[tmp.presence.key, \"epresenceScore\"], sep = ',')\n      }\n    }\n  }\n\n  # Compute supplementary stats from the gathered data\n  # --> presence.freq: frequency of edge 'presence' over the number of edge 'possible'\n  # --> presence.ort: the consensus orientation (using a simple max rule...no orientation if 2 max!)\n  globalNet.supp.col <- c(\"presence.freq\", \"presence.ort\")\n  globalNet.supp <- as.data.frame(matrix(NA, ncol = length(globalNet.supp.col), nrow = nrow(globalNet)))\n  rownames(globalNet.supp) <- rownames(globalNet)\n  colnames(globalNet.supp) <- globalNet.supp.col\n\n  # --> presence.freq:\n  globalNet.supp[, \"presence.freq\"] <- (globalNet[, \"presence\"]/globalNet[, \"possible\"])\n\n  # --> presence.ort:\n  max.ort.list <- plyr::alply(globalNet[,c(\"forward\", \"backward\")], 1, function(x){which(x==max(x))})\n  names(max.ort.list) <- c()\n  max.ort.list.length <- unlist(lapply(max.ort.list, length))\n\n  # single max ==>\n  # --> set the name of the corresponding orientation type (forward, backward)\n  # --> then replace with integer 2, -2\n  if(length(which(max.ort.list.length == 1))>0){\n\n    globalNet.supp[which(max.ort.list.length == 1), \"presence.ort\"] <- names(unlist(max.ort.list[which(max.ort.list.length == 1)]))\n\n    tmp.idx <- which(globalNet.supp[, \"presence.ort\"] == \"forward\")\n    if(length(tmp.idx) > 0){ globalNet.supp[tmp.idx, \"presence.ort\"] <- rep(\"2\", length(tmp.idx)) }\n\n    tmp.idx <- which(globalNet.supp[, \"presence.ort\"] == \"backward\")\n    if(length(tmp.idx) > 0){ globalNet.supp[tmp.idx, \"presence.ort\"] <- rep(\"-2\", length(tmp.idx)) }\n\n    globalNet.supp[, \"presence.ort\"] <- as.numeric(globalNet.supp[, \"presence.ort\"])\n  }\n\n  # Set 1 for the orientation otherwise\n  tmp.idx <- which(is.na(globalNet.supp[, \"presence.ort\"]) & (globalNet.supp[, \"presence.freq\"] > 0) )\n  if(length(tmp.idx) > 0){ globalNet.supp[tmp.idx, \"presence.ort\"] <- rep(1, length(tmp.idx)) }\n\n  # --> presence eigenvect pos/neg\n  # ----> remove first \"NA,\" for !NA data\n  tmp.col <- ifelse((ioSubEnv$subset.select %in% c(\"spectral\", \"random\")), \"eigen\", \"cluster\")\n  tmp.key <- rownames(globalNet.cmpl)[which(!is.na(globalNet.cmpl[, tmp.col]))]\n  tmp.vect <- sapply(globalNet.cmpl[tmp.key, tmp.col], gsub, pattern = \"^NA,\", replacement = \"\")\n  names(tmp.vect) <- tmp.key\n  globalNet.cmpl[tmp.key, tmp.col] <- tmp.vect[tmp.key]\n\n  # --> epresenceScore\n  # ----> remove first \"NA,\" for !NA data\n  tmp.col <- c(\"epresenceScore\")\n  tmp.key <- rownames(globalNet.cmpl)[which(!is.na(globalNet.cmpl[, tmp.col]))]\n  tmp.vect <- sapply(globalNet.cmpl[tmp.key, tmp.col], gsub, pattern = \"^NA,\", replacement = \"\")\n  names(tmp.vect) <- tmp.key\n  globalNet.cmpl[tmp.key, tmp.col] <- tmp.vect[tmp.key]\n\n  # Use the rownames to write the x and y columns, and cbind all the information\n  globalNet <- cbind.data.frame(data.frame(do.call('rbind', strsplit(rownames(globalNet),\"_<<_\",\n                                                                     fixed=TRUE))),\n                                globalNet, globalNet.supp, globalNet.cmpl)\n  colnames(globalNet) <- c(\"x\", \"y\",\n                           globalNet.colnames,\n                           colnames(globalNet.supp),\n                           colnames(globalNet.cmpl))\n  # --!-- Time\n  ioSubEnv$gather.time <- (proc.time() - time.globalReconstruction.start)\n  ioSubEnv$total.time <- ioSubEnv$total.time + ioSubEnv$gather.time\n\n  # Create output directory for the global graph\n  tmp.dirPath <- file.path(ioSubEnv$output.dirPath, \"globalGraph\")\n  if(!dir.exists(tmp.dirPath)){dir.create(tmp.dirPath)}\n\n  tmp.prefix <- ifelse((ioSubEnv$subset.select == \"spectralFuzzyCmeansSample\"),\n                       paste(\"_globalNet_\", iVarSpl, \".txt\", sep=''),\n                       paste(\"_globalNet\", ioSubEnv$recons.method,\"txt\", sep = '.'))\n\n  globalNet.filePath <- file.path(tmp.dirPath, gsub(\".txt\", tmp.prefix, basename(ioSubEnv$inputData.filePath)))\n  write.table(globalNet, file = globalNet.filePath, col.names = TRUE, row.names = FALSE, sep = \"\\t\", quote = FALSE)\n}\n",
    "created" : 1470661222835.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3580768387",
    "id" : "E7014088",
    "lastKnownWriteTime" : 1470662242,
    "path" : "~/Projects/Projects_largeScale/package/ScaleNet_V1.2/R/scaleNet.gatherSubGraphs.R",
    "project_path" : "R/scaleNet.gatherSubGraphs.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}